# This Fastfile defines the automation lanes for building, testing, and releasing the Mobile SDK Android project.
# It uses Fastlane to interact with the Android build system, Git, and external services like GitLab and GitHub.

default_platform(:android) # Specifies that this Fastfile is for Android.

platform :android do

    # --- Linting Lanes ---

    desc "Run Detekt formatting and analysis"
    lane :code_quality do
        # Run detekt on the entire codebase
        gradle(task: "detektFormat")
        gradle(task: "detektAll")
    end

    # --- Version Lanes ---

    desc "Update the version name in GitLab CI variables"
    lane :update_version_name do
        # Get the current branch name
        current_branch = ENV["CI_COMMIT_BRANCH"] || "main"

        # Get the current version name and code from GitLab CI variables
        current_version_name = get_gitlab_ci_variable(key: "VERSION_NAME")

        # Increment the version name (patch version)
        major, minor, patch = current_version_name.split(".").map(&:to_i)
        next_version_name = "#{major}.#{minor}.#{patch + 1}"

        # Update GitLab CI variables
        update_gitlab_ci_variable(key: "VERSION_NAME", value: next_version_name)

        # Print for debugging
        puts "Current Version Name: #{current_version_name}"
        puts "Next Version Name: #{next_version_name}"

        # Update the versions on the build.gradle.kts
        update_build_gradle_version_name(version_name: next_version_name)
    end

    desc "Update the version code in GitLab CI variables"
    lane :update_version_code do
        # Get the current branch name
        current_branch = ENV["CI_COMMIT_BRANCH"] || "main"

        # Get the current version name and code from GitLab CI variables
        current_version_code = get_gitlab_ci_variable(key: "VERSION_CODE")

        # Check if the current_version_code is an integer
        if current_version_code.to_i.to_s != current_version_code
            UI.user_error!("VERSION_CODE must be an integer in GitLab CI variables.")
        end

        # Increment the version code
        next_version_code = current_version_code.to_i + 1

        # Update GitLab CI variables
        update_gitlab_ci_variable(key: "VERSION_CODE", value: next_version_code)

        # Print for debugging
        puts "Current Version Code: #{current_version_code}"
        puts "Next Version Code: #{next_version_code}"

        # Update the versions on the build.gradle.kts
        update_build_gradle_version_code(version_code: next_version_code)
    end

    # Update a CI variable in GitLab.
    #
    # @param key [String] the name of the CI variable to update
    # @param value [String, Integer] the new value for the CI variable
    def update_gitlab_ci_variable(key:, value:)
        gitlab_token = ENV["GITLAB_TOKEN"]
        unless gitlab_token
            UI.user_error!("Missing GITLAB_TOKEN environment variable")
        end

        project_id = ENV["CI_PROJECT_ID"]
        unless project_id
            UI.user_error!("Missing CI_PROJECT_ID environment variable")
        end

        api_endpoint = ENV["CI_API_V4_URL"]
        unless api_endpoint
            UI.user_error!("Missing CI_API_V4_URL environment variable")
        end

        api_url = "#{api_endpoint}/projects/#{project_id}/variables/#{key}"

        # We now use -s and --show-error to remove the extra output
        response = sh("curl -s --show-error --request PUT --header 'Content-Type: application/json' --header 'PRIVATE-TOKEN: #{gitlab_token}' \
            --data '{\"value\":\"#{value}\", \"variable_type\":\"env_var\"}' \
            '#{api_url}'")

        # check if the command was successful.
        parsed_response = JSON.parse(response)
        if parsed_response["key"] != key
            UI.user_error!("Error setting GitLab variable: #{key}")
        end
    end

    # Get a CI variable from GitLab.
    #
    # @param key [String] the name of the CI variable to get
    # @return [String] the value of the CI variable, or "" if it's not set
    def get_gitlab_ci_variable(key:)
        # Check if the variable is set
        unless ENV[key]
            UI.user_error!("Missing CI variable: #{key}")
        end

        # Return the variable value
        return ENV[key]
    end

    # Updates the version name and version code in the build.gradle.kts file.
    #
    # @param version_name [String] The new version name.
    def update_build_gradle_version_name(version_name:)
        # Construct the path to the build.gradle.kts file.
        build_gradle_path = "../sample/build.gradle.kts"

        # Read the entire file content.
        file_content = File.read(build_gradle_path)

        # Replace the version name line.
        file_content.gsub!(/versionName = ".*"/, "versionName = \"#{version_name}\"")

        # Write the modified content back to the file.
        File.write(build_gradle_path, file_content)

        puts "Updated #{build_gradle_path} with versionName: #{version_name}"
    end

    # Updates the version name and version code in the build.gradle.kts file.
    #
    # @param version_code [Integer] The new version code.
    def update_build_gradle_version_code(version_code:)
        # Construct the path to the build.gradle.kts file.
        build_gradle_path = "../sample/build.gradle.kts"

        # Read the entire file content.
        file_content = File.read(build_gradle_path)

        # Replace the version code line.
        file_content.gsub!(/versionCode = \d+/, "versionCode = #{version_code}")

        # Write the modified content back to the file.
        File.write(build_gradle_path, file_content)

        puts "Updated #{build_gradle_path} with versionCode: #{version_code}"
    end

    # --- Build Lanes ---

    desc "Builds the debug Android app for the specified flavor"
    lane :buildDebug do |options|
        flavor = options[:flavor] || "staging" # Default to staging if no flavor is provided
        versionCode = get_gitlab_ci_variable(key: "VERSION_CODE")
        update_build_gradle_version_code(version_code: versionCode)
        gradle(task: "assemble", flavor: flavor.capitalize, build_type: "Debug")
    end

    desc "Builds the release Android app for the specified flavor"
    lane :buildRelease do |options|
        flavor = options[:flavor] || "staging" # Default to staging if no flavor is provided
        versionCode = get_gitlab_ci_variable(key: "VERSION_CODE")
        update_build_gradle_version_code(version_name: versionName, version_code: versionCode)
        gradle(task: "assemble", flavor: flavor.capitalize, build_type: "Release")
    end

    # --- Test Lane ---

    desc "Runs all unit tests for specified flavor"
    lane :test do |options|
         flavor = options[:flavor] || "staging" # Default to staging if no flavor is provided
         build_type = options[:build_type] || "Debug" # Default to Debug if no build type is provided

        # This lane runs all the unit tests for the Android application.
        # It uses the 'gradle' action to execute the 'test' Gradle task.
        gradle(task: "test#{flavor.capitalize}#{build_type.capitalize}UnitTest")
    end

    # -- Deploy Lane --

    desc "Deploys the Build to Firebase App Distribution for the specified flavor"
    lane :deploy do |options|
        # find apk path
        flavor = options[:flavor] || "staging" # Default to staging if no flavor is provided

        output_path = "./sample/build/outputs/apk/#{flavor}/debug/"
        output_json_path = output_path + "output-metadata.json"
        build_output = load_json(json_path: output_json_path)
        elements = build_output["elements"][0]
        apk_path = output_path + elements["outputFile"]

        # Get Git information
        branch = git_branch
        commit = last_git_commit
        commit_author = commit[:author]
        commit_message = commit[:message]

        # Format release notes
        release_note_information = <<~RELEASE_NOTES
            ðŸš€ New Build Deployed! ðŸš€

            ðŸ“Œ Branch: #{branch}
            ðŸ‘¤ Developer: #{commit_author}

            ðŸ“ Changes:
            - #{commit_message}
        RELEASE_NOTES

        # Append any additional notes passed as options[:r]
        release_note = "#{release_note_information}\n#{options[:r]}"

        # Print the release notes for debugging
        puts "Release Notes:\n#{release_note}"

        firebase_app_distribution(
            app: ENV["APP_ID"],
            android_artifact_type: "APK",
            apk_path: apk_path,
            release_notes: "#{release_note}",
    #              firebase_cli_token: ENV["FIREBASE_TOKEN"],
            groups: "Testers",
            service_credentials_file: ENV["GOOGLE_CREDENTIALS_FILE_PATH"],
            debug: true
        )
    end

    # --- Release Lanes ---

    desc "Creates and pushes a tag on GitLab"
    lane :tag_release do
        # This lane automates the process of creating and pushing a tag to the GitLab repository.
        # It extracts the version number from the Gradle output, creates a Git tag, and pushes it to the remote repository.

        # Get the version name from the Gradle output.
        result = gradle(task: "-q :mobile-sdk:printVersionName", print_command: false, print_command_output: true)
        # The 'gradle' action is used to execute a Gradle task.
        #   - '-q' flag: Runs Gradle in quiet mode.
        #   - ':mobile-sdk:printVersionName': The specific Gradle task to run, which prints the version name.
        #   - 'print_command: false': Prevents the Gradle command from being printed to the console.
        #   - 'print_command_output: true': Prints the output of the Gradle command to the console.

        # Extract version number using a regular expression.
        version_match = result.match(/(\d+\.\d+\.\d+)/) # Match a pattern like "1.0.0"
        version_name = version_match[1] if version_match # Extracts the version number from the match.

        # Configure Git user (if needed).
        sh("git config --global user.email \"ricardo.dasilva@paydock.com\"") # Sets the Git user email.
        sh("git config --global user.name \"Ricardo\"") # Sets the Git user name.
        # The 'sh' action is used to execute shell commands.

        # Create and push the tag.
        sh("git tag -a #{version_name} -m \"Release version #{version_name}\"") # Creates an annotated Git tag.
        #   - '-a': Creates an annotated tag.
        #   - '#{version_name}': The tag name (e.g., "1.0.0").
        #   - '-m': Specifies the tag message.

        # Use the GITLAB_TOKEN environment variable for authentication.
        git_url_with_token = "https://gitlab-ci-token:#{ENV['GITLAB_TOKEN']}@gitlab.com/paydock/bounded-contexts/mobile/mobile-sdk-android-powerboard.git"
        sh("git remote set-url origin #{git_url_with_token}") # Updates the remote URL to include the token.
        #   - 'ENV['GITLAB_TOKEN']': Accesses the 'GITLAB_TOKEN' environment variable.

        # Push the tag to the remote repository.
        sh("git push origin #{version_name}") # Pushes the tag to the remote repository.
    end

    desc "Creates a release on GitLab"
    lane :create_gitlab_release do |options|
        # This lane automates the process of creating a release on GitLab.
        # It is designed to be triggered when a new tag is pushed to the 'release' branch.

        # Extract the version tag from the options, environment variables, or Git tags.
        # If 'version' is passed as an option, it's used; otherwise, CI_COMMIT_TAG is checked.
        # If neither is available, it falls back to the latest Git tag.
        version_tag = options[:version] || ENV["CI_COMMIT_TAG"] || sh("git describe --tags --abbrev=0").strip
        # Remove the leading 'v' from the version tag if present.
        version_tag = version_tag.gsub(/^v/, '')

        # Ensure a version tag is available; otherwise, raise an error.
        unless version_tag
            UI.user_error!("No version tag provided. Ensure you pass 'version' as an option or set CI_COMMIT_TAG.")
        end

        # Extract information from environment variables.
        # These variables are typically set by the CI/CD pipeline.
        tag_name = ENV["CI_COMMIT_TAG"] # The tag name from the CI/CD environment.
        project_id = ENV["CI_PROJECT_ID"] # The project ID from the CI/CD environment.
        gitlab_token = ENV["GITLAB_TOKEN"] # The GitLab API token from the CI/CD environment.
        api_endpoint = ENV["CI_API_V4_URL"] # The GitLab API endpoint from the CI/CD environment.

        # Read the changelog file to get the release notes for the specified version.
        changelog_notes = get_release_notes(version_tag)

        # Construct the release details.
        # This includes the release name and a description that includes the changelog notes.
        release_name = "Release: v#{version_tag}" # The name of the release.
        release_description = <<~RELEASE
            #{changelog_notes}

            **Full Changelog:** [View on GitLab](https://github.com/CommBank-PowerBoard/powerboard-android-mobile-sdk/commits/#{version_tag})
        RELEASE

        # Define the release assets.
        # These are links to external resources related to the release.
        release_assets = [
            {
                "name" => "MobileSDK Documentation", # The name of the asset.
                "url" => "https://developer.powerboard.commbank.com.au/reference/getting-started-with-powerboard" # The URL of the asset.
            }
        ]

        # Construct the release data payload.
        # This is the data that will be sent to the GitLab API to create the release.
        release_data = {
            "name" => release_name, # The name of the release.
            "tag_name" => version_tag, # The tag name of the release.
            "description" => release_description, # The description of the release.
            "ref" => version_tag, # The reference (tag or branch) for the release.
            "assets" => { # The assets associated with the release.
                "links" => release_assets # The links to the assets.
            }
        }.to_json # Convert the data to JSON format.

        # Construct the correct API URL.
        # This is the URL that will be used to create the release via the GitLab API.
        api_url = "#{api_endpoint}/projects/#{project_id}/releases"

        # Create the release using the GitLab API. https://docs.gitlab.com/api/releases/
        # This uses the 'curl' command to send a POST request to the GitLab API.
        # --silent: Suppresses progress output.
        # --header: Specifies the headers for the request (Content-Type and PRIVATE-TOKEN).
        # --data: Specifies the data payload for the request (the release data in JSON format).
        # --request POST: Specifies that this is a POST request.
        response = sh("curl --silent --header 'Content-Type: application/json' --header 'PRIVATE-TOKEN: #{gitlab_token}' \
            --data '#{release_data}' \
            --request POST '#{api_url}'")

        # Output the GitLab API response for debugging purposes.
        puts "ðŸ“¢ GitLab API Response: #{response}"

        # Indicate that the GitLab release was created successfully.
        UI.success("âœ… GitLab release created successfully: #{release_name}")
    end

    desc "Creates a release on GitHub"
    lane :create_github_release do |options|
        # This lane automates the process of creating a release on GitHub.
        # It extracts the version name from the Git tag, authenticates with GitHub, and creates a new release.

        # Extract version name from tag (assuming tags are in the format "v1.0.0").
        version_tag = options[:version] || ENV["CI_COMMIT_TAG"] || sh("git describe --tags --abbrev=0").strip
        # The 'sh' action is used to execute shell commands.
        #   - 'git describe --tags --abbrev=0': Gets the latest tag name.
        #   - '.strip': Removes leading/trailing whitespace.

        require 'octokit' # Loads the Octokit library for interacting with the GitHub API.

        # Authenticate with GitHub (assuming GITHUB_TOKEN is set in your CI/CD variables).
        # Set up Octokit client.
        client = Octokit::Client.new(access_token: ENV['GITHUB_TOKEN']) # Creates an Octokit client.

        # Get release notes from CHANGELOG.md
        release_notes = get_release_notes(version_tag)

        # Create a release on GitHub.
        repo = 'CommBank-PowerBoard/powerboard-android-mobile-sdk' # Replace with your GitHub repository
        release_name = "v#{version_tag}" # Creates the release name (e.g., "v1.0.0").
        release_body = <<~RELEASE
            #{release_notes}

            **Full Changelog:** [View on GitLab](https://github.com/CommBank-PowerBoard/powerboard-android-mobile-sdk/commits/#{version_tag})
        RELEASE

        release = client.create_release(repo, "#{version_tag}", { # Creates the release on GitHub.
          tag_name: "#{version_tag}", # Sets the tag name.
          name: release_name, # Sets the release name.
          body: release_body, # Sets the release body.
          is_generate_release_notes: false, # Disables automatic generation of release notes.
          make_latest: 'true' # Marks the release as the latest.
        })
        # The 'client.create_release' method is used to create the release.
    end

    # Extracts the release notes for a specific version from the CHANGELOG.md file.
    #
    # @param version [String] The version number to extract release notes for (e.g., "2.3.0").
    # @return [String] The release notes for the specified version, or an empty string if no entry is found.
    def get_release_notes(version)
        # Read the changelog file
        changelog_path = "../CHANGELOG.md"
        changelog_content = File.read(changelog_path)
        match = changelog_content.match(/^##\s+\[#{Regexp.escape(version)}\].*?\n(.*?)(?=\n##\s+\[|\z)/m)
        if match
          return match[1].strip
        else
          UI.message("âš ï¸ No changelog entry found for version #{version}.")
          return "" # Return an empty string if no changelog entry is found
        end
    end

    # Extracts the changelog content for a specific version from a given changelog content string.
    #
    # This function is a helper function that is used by `get_release_notes`.
    # It takes the entire changelog content as a string and the version to search for.
    # It then uses a regular expression to find the section of the changelog that corresponds to the given version.
    #
    # @param changelog_content [String] The entire content of the changelog file as a string.
    # @param version [String] The version number to extract changelog content for (e.g., "2.3.0").
    # @return [String] The changelog content for the specified version, or a message indicating no entry was found.
    def extract_changelog_for_version(changelog_content, version)
        match = changelog_content.match(/^##\s+\[#{Regexp.escape(version)}\].*?\n(.*?)(?=\n##\s+\[|\z)/m)
        if match
          return match[1].strip
        else
          return "No changelog entry found for version #{version}"
        end
    end

    # --- Publish Lanes ---

    desc "Publishes the SDK to GitHub Packages"
    lane :publish_to_github do
        # This lane publishes the built SDK to GitHub Packages.
        # It uses the 'gradle' action to execute the 'publishAllPublicationsToGitHubPackagesRepository' Gradle task.
        gradle(task: ":mobile-sdk:publishAllPublicationsToGitHubPackagesRepository")
    end
end